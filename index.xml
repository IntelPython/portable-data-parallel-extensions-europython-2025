<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Portable Data-Parallel Python Extensions with oneAPI</title><link>https://IntelPython.github.io/portable-data-parallel-extensions-europython-2025/</link><description>Recent content on Portable Data-Parallel Python Extensions with oneAPI</description><generator>Hugo</generator><language>en</language><lastBuildDate>Thu, 10 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://IntelPython.github.io/portable-data-parallel-extensions-europython-2025/index.xml" rel="self" type="application/rss+xml"/><item><title>About oneAPI</title><link>https://IntelPython.github.io/portable-data-parallel-extensions-europython-2025/docs/oneapi/</link><pubDate>Thu, 10 Jul 2025 00:00:00 +0000</pubDate><guid>https://IntelPython.github.io/portable-data-parallel-extensions-europython-2025/docs/oneapi/</guid><description>&lt;p>The Unified Acceleration Foundation (&lt;a href="https://uxlfoundation.org/">UXL&lt;/a>) under the umbrella of Linux Foundation is driving an open standard accelerator software ecosystem that includes compilers and performance libraries. This software ecosystem standardizes programming of different types of accelerators, such as multi-core CPUs, GPUs, some FPGAs, etc. from different vendors.&lt;/p>
&lt;p>Intel&amp;rsquo;s oneAPI DPC++ compiler is an implementation of the &lt;a href="https://registry.khronos.org/SYCL/specs/sycl-2020/html/sycl-2020.html">SYCL-2020 standard&lt;/a> that is a part of UXL foundation&amp;rsquo;s overall language design standardization for accelerator programming in C++. The compiler is being developed in &lt;a href="https://github.com/intel/llvm">https://github.com/intel/llvm&lt;/a>, and supports offloading to Intel(R) GPUs, NVidia(R) GPUs, and AMD GPUs.&lt;/p></description></item><item><title>First DPC++ app</title><link>https://IntelPython.github.io/portable-data-parallel-extensions-europython-2025/docs/first-app/</link><pubDate>Thu, 10 Jul 2025 00:00:00 +0000</pubDate><guid>https://IntelPython.github.io/portable-data-parallel-extensions-europython-2025/docs/first-app/</guid><description>&lt;p>For an in-depth introduction to SYCL and to accelerators programming please refer to the &amp;ldquo;&lt;a href="https://link.springer.com/book/10.1007/978-1-4842-9691-2">Data Parallel C++&lt;/a>&amp;rdquo; open access e-book.&lt;/p>
&lt;p>A SYCL application runs on SYCL platform (host, connected to one or more heterogeneous devices). The application is structured in three scopes: application scope, command group scope, and kernel scope. The kernel scope specifies a single kernel function that will be compiled by the device
compiler and executed on the device. The command group scope specifies a unit work which includes the kernel function, preparation of
its arguments and specifying execution ordering information. The application scope specifies all the other code outside of command group scope.
Execution of SYCL application begins in the application scope.&lt;/p></description></item><item><title>KDE DPC++ example</title><link>https://IntelPython.github.io/portable-data-parallel-extensions-europython-2025/docs/kde-cpp/</link><pubDate>Thu, 10 Jul 2025 00:00:00 +0000</pubDate><guid>https://IntelPython.github.io/portable-data-parallel-extensions-europython-2025/docs/kde-cpp/</guid><description>&lt;p>Given a sample of \(n\) observations \(x_i\) drawn from an unknown underlying continuous distribution \(f(x)\),
the kernel density estimate of that density function is computed as follows, for some kernel
smoothing parameter \(h \in \mathbb{R}\):&lt;/p>
&lt;p>$$
\hat{f}(x) = \frac{1}{n} \sum_{i=1}^{n} \frac{1}{h} K\left(\frac{x - x_i}{h}\right)
$$&lt;/p>
&lt;p>An example of NumPy code performing the estimation, for a common choice of kernel function as standard
\(d\)-dimensional Gaussian distribution:&lt;/p>
&lt;!-- See https://stackoverflow.com/questions/5319754/cross-reference-named-anchor-in-markdown //-->
&lt;p>&lt;a id="kde_numpy" href="">&lt;/a>&lt;/p></description></item><item><title>KDE Python extension</title><link>https://IntelPython.github.io/portable-data-parallel-extensions-europython-2025/docs/kde-python/</link><pubDate>Thu, 10 Jul 2025 00:00:00 +0000</pubDate><guid>https://IntelPython.github.io/portable-data-parallel-extensions-europython-2025/docs/kde-python/</guid><description>&lt;p>Since SYCL builds on C++, we are going to use the &lt;code>pybind11&lt;/code> project to generate a Python extension.
We also need Python objects to carry USM allocations of input and output data, such as &lt;code>dpctl&lt;/code> (&lt;a href="https://github.com/IntelPython/dpctl.git">Data Parallel Control&lt;/a> Python package). The &lt;code>dpctl&lt;/code> package also provides Python objects corresponding to DPC++ runtime objects:&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>Python object&lt;/th>
 &lt;th>SYCL C++ object&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;code>dpctl.SyclQueue&lt;/code>&lt;/td>
 &lt;td>&lt;code>sycl::queue&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>dpctl.SyclDevice&lt;/code>&lt;/td>
 &lt;td>&lt;code>sycl::device&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>dpctl.SyclContext&lt;/code>&lt;/td>
 &lt;td>&lt;code>sycl::context&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>dpctl.SyclEvent&lt;/code>&lt;/td>
 &lt;td>&lt;code>sycl::event&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;code>dpctl&lt;/code> provides integration with &lt;code>pybind11&lt;/code> supporting castings between &lt;code>dpctl&lt;/code> Python objects and corresponding C++ SYCL classes listed in the table above. Furthermore, the integration provides the C++ class &lt;code>dpctl::tensor::usm_ndarray&lt;/code> which derives from &lt;code>pybind11::object&lt;/code>.
It stores the &lt;code>dpctl.tensor.usm_ndarray&lt;/code> object and provides methods to query its attributes, such as data pointer, dimensionality, shape, strides
and elemental type information. Underlying &lt;code>dpctl.tensor.usm_ndarray&lt;/code> is a SYCL unified shared memory (USM) allocation. See the &lt;a href="https://registry.khronos.org/SYCL/specs/sycl-2020/html/sycl-2020.html#sec:usm">SYCL standard&lt;/a> or &lt;a href="https://intelpython.github.io/dpctl/latest/api_reference/dpctl/memory.html#dpctl-memory-pyapi">dpctl.memory documentation&lt;/a> for more details.&lt;/p></description></item><item><title>oneMath Python extension</title><link>https://IntelPython.github.io/portable-data-parallel-extensions-europython-2025/docs/onemath/</link><pubDate>Thu, 10 Jul 2025 00:00:00 +0000</pubDate><guid>https://IntelPython.github.io/portable-data-parallel-extensions-europython-2025/docs/onemath/</guid><description>&lt;p>Given a matrix \(A\), the QR decomposition of \(A\) is defined as the decomposition of \(A\) into the product of matrices \(Q\) and \(R\) such that \(Q\) is orthonormal and \(R\) is upper-triangular.&lt;/p>
&lt;p>QR factorization is a common routine in more optimized LAPACK libraries, so rather than write and implement an algorithm ourselves, it would be preferable to find a suitable library routine.&lt;/p>
&lt;p>Since &lt;code>dpctl.tensor.usm_ndarray&lt;/code> is a Python object with an underlying USM allocation, it is possible to write extensions which wrap &lt;code>oneAPI Math Library&lt;/code> (&lt;a href="https://github.com/uxlfoundation/oneMath">oneMath&lt;/a>) USM routines and then call them on the &lt;code>dpctl.tensor.usm_ndarray&lt;/code> from Python. These low-level routines can greatly improve the performance of an extension.&lt;/p></description></item><item><title>Search Results</title><link>https://IntelPython.github.io/portable-data-parallel-extensions-europython-2025/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://IntelPython.github.io/portable-data-parallel-extensions-europython-2025/search/</guid><description/></item></channel></rss>